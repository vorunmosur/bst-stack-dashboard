import streamlit as st

st.set_page_config(page_title="Ohmium Dashboard v1", layout="wide")

st.title("Ohmium Stack Monitoring - Dashboard v1")
st.write("Welcome to the Ohmium Stack Monitoring Dashboard. This dashboard provides insights into the performance and status of the Ohmium stack components.")

#maybe shift this loader below the purpose section
st.header("1. Upload BST Logfiles")

uploaded_files = st.file_uploader(
    "Upload one or more  BST csv logfiles (24h each) for analysis *up to 3 files accepted*",
    type=["csv"],
    accept_multiple_files=True,
 #   help="Select logfiles generated by the BST system for the last 24 hours.",
)

if not uploaded_files:
    st.info("Please upload BST logfiles to proceed with the analysis.")
    st.stop()

st.success(f"{len(uploaded_files)} file(s) uploaded successfully.")

# - Understand the current state of the Ohmium stack
# - Monitor key performance indicators
# - Identify potential issues or bottlenecks
# - Track system health over time

st.markdown(
    """
    **Purpose**
    - Upload BST logfiles(24h)
    - Compare up to 3 stacks
    -  Visualize parameters and health score
    -  Understand *why* health degrades
    """
)


# Load & Standardize BST Data(robust to different csv formats ideally)
import pandas as pd

@st.cache_data
def load_bst_data(files):
    try:
        df = pd.read_csv(file, low_memory=False)
    except Exception as e:
        st.error(f"Failed to read {file.name}: {e}")
        return None

    # Normalize column names
    df.columns = df.columns.str.strip()

    # Time column
    if "Time" in df.columns:
        df["Time"] = pd.to_datetime(df["Time"], errors="coerce")
    else:
        st.error(f"'Time' column not found in {file.name}.")
        return None
    df = df.dropna(subset=["Time"]).sort_values(by="Time")
    return df

# Load data from all uploaded files
dfs = []
for file in uploaded_files:
    df = load_bst_data(file)
    if df is not None:
        dfs[file.name] = df

if not dfs:
    st.error("No valid files uploaded.")
    st.stop()

# Stack Selection
st.header("2. Select Stacks for Comparison")
stack_names = list(dfs.keys())

selected_stacks = st.multiselect(
    "Select up to 3 stacks to compare:",    
    options=stack_names,
    default=stack_names[:1],
    max_selections=3
)

if not selected_stacks:
    st.info("Please select at least one stack to proceed.")
    st.stop()

# Parameter Selection
PARAM_MAP = {
    "Avg Cell Voltage": "avg_cell_voltage",
    "Flow Rate(FLM 101)": "FLM 101",
    "Pressure(PRT 102)": "PRT 102",
    "Conductivity (COS 101)": "COS 101",
    "Stack Current": "stack_current"
}

st.header("3. Select Parameters to Visualize")
param_label = st.selectbox(
    "Select Parameter to plot:",
    list(PARAM_MAP.keys())
#   options=list(PARAM_MAP.keys()),
 #  index=0
)
param_col = PARAM_MAP[param_label]

# Compute derived metrics(BST-specific calculations)
def enrich_bst_df(df):
    df = df.copy()

    # Cell Voltages
    cell_cols = [c for c in df.columns if c.startswith("Cell")]
    if cell_cols:
        df[cell_cols] = df[cell_cols].apply(pd.to_numeric, errors="coerce")
        df["avg_cell_voltage"] = df[cell_cols].mean(axis=1)
        df["cell_spread"] = df[cell_cols].max(axis=1) - df[cell_cols].min(axis=1)

    # Stack Current(Sum of PSU OP I)
    psu_i_cols = [c for c in df.columns if "OP I" in c]
    if psu_i_cols:
        df[psu_i_cols] = df[psu_i_cols].apply(pd.to_numeric, errors="coerce")
        df["stack_current"] = df[psu_i_cols].sum(axis=1)
    return df

for k in selected_stacks:
    dfs[k] = enrich_bst_df(dfs[k])

# Plot Comparison
import matplotlib.pyplot as plt
st.header("4. Time-Series Comparison")  

fig, ax = plt.subplots(figsize=(12, 4))
for stack in selected_stacks: # exchange stack with'name'if it does not work
    df = dfs[stack]
    if param_col not in df.columns:
        st.warning(f"Parameter '{param_col}' not found in {stack}. Skipping.")
        continue
    ax.plot(df["Time"], df[param_col], label=stack, alpha=0.8)

ax.set_title(f"Comparison of {param_label}")
ax.set_xlabel("Time")   
ax.set_ylabel(param_label)
ax.legend()
ax.grid(True)
st.pyplot(fig)

# Health Score Calculation
def compute_features(df):
    cell_cols = [c for c in df.columns if c.startswith("Cell")]
    df[cell_cols] = df[cell_cols].apply(pd.to_numeric, errors="coerce")

    df["avg_cell_voltage"] = df[cell_cols].mean(axis=1)
    df["cell_spread"] = df[cell_cols].max(axis=1) - df[cell_cols].min(axis=1)

    df["flow"] = pd.to_numeric(df["FLM 101"], errors="coerce")
    df["cond"] = pd.to_numeric(df["COS 101"], errors="coerce")
    return df

def compute_penalties(df):
    baseline = {
        "voltage": df["avg_cell_voltage"].median(),
        "spread": df["cell_spread"].median(),
        "flow": df["flow"].median(),
        "cond": df["cond"].median(),
    }
 
    df["penalty_voltage"] = ((df["avg_cell_voltage"] - baseline["voltage"]) / baseline["voltage"]).clip(lower=0)
    df["penalty_spread"]  = ((df["cell_spread"] - baseline["spread"]) / baseline["spread"]).clip(lower=0)
    df["penalty_flow"]    = ((baseline["flow"] - df["flow"]) / baseline["flow"]).clip(lower=0)
    df["penalty_cond"]    = ((df["cond"] - baseline["cond"]) / baseline["cond"]).clip(lower=0)
 
    return df

WEIGHTS = {
    "voltage": 40,
    "spread": 30,
    "flow": 20,
    "cond": 10
}
 
def compute_health_score(df):
    df["health_score"] = (
        100
        - WEIGHTS["voltage"] * df["penalty_voltage"]
        - WEIGHTS["spread"]  * df["penalty_spread"]
        - WEIGHTS["flow"]    * df["penalty_flow"]
        - WEIGHTS["cond"]    * df["penalty_cond"]
    ).clip(0, 100)
 
    return df

def classify_zone(score):
    if score < 60:
        return "RED"
    elif score < 80:
        return "AMBER"
    else:
        return "GREEN"
    
def dominant_driver(row):
    penalties = {
        "Voltage": row["penalty_voltage"] * WEIGHTS["voltage"],
        "Cell Spread": row["penalty_spread"] * WEIGHTS["spread"],
        "Flow Rate": row["penalty_flow"] * WEIGHTS["flow"],
        "Conductivity": row["penalty_cond"] * WEIGHTS["cond"],
    }
    return max(penalties, key=penalties. Get)

# check from might be lil problematic
#   df["is_red"] = df["health_score"] < RED_THRESHOLD

#   PERSISTENCE_MINUTES = 30
#   WINDOW = PERSISTENCE_MINUTES // sampling_interval_minutes
 
#   df["red_sustained"] = (
#       df["is_red"]
#       .rolling(WINDOW, min_periods=WINDOW)
#       .sum() == WINDOW
#   )
#  penalties = {
#    "voltage": df.loc[t, "penalty_voltage"],
#    "cell_spread": df.loc[t, "penalty_cell_spread"],
#    "flow": df.loc[t, "penalty_flow"],
#    "conductivity": df.loc[t, "penalty_cond"]
# }
 
#   dominant_driver = max(penalties, key=penalties. Get)

# 22 jan onwards code:


